# 多智能体狼人杀游戏技术方案

## 1. 项目概述

本项目是一个基于 `agentscope` 框架实现的多智能体（Multi-Agent）狼人杀游戏。它通过模拟一个经典的社交推理游戏场景，探索了多个AI智能体在复杂规则下的自主决策、信息交互和协作博弈能力。项目中包含一个作为游戏控制核心的“裁判”智能体，以及多个由大型语言模型（LLM）驱动的“玩家”智能体，同时支持一名人类玩家参与游戏。

## 2. 多智能体框架的优势 (对比独立API调用)

采用 `agentscope` 这样的多智能体框架，而非直接调用多个独立的LLM API，为项目带来了决定性的优势：

- **1. 结构化的状态管理与逻辑编排**:
  - **独立API调用**: 如果直接调用API，开发者需要自行维护一个庞大而复杂的状态机来跟踪每个玩家的身份、存活状态、技能使用情况以及游戏进程。这将导致大量的全局变量和复杂的条件判断，代码难以维护。
  - **框架优势 (`GameMasterAgent`)**: `GameMasterAgent` 作为中心化的“大脑”，统一管理所有游戏状态。它将复杂的游戏规则封装成清晰的方法（如 `_night_phase`, `_vote_phase`），并按顺序进行编排。这使得整个游戏逻辑清晰、可预测且易于调试。

- **2. 优雅的通信抽象**:
  - **独立API调用**: 实现复杂的通信模式（如“向所有人广播” vs. “只告诉狼人”）需要手动构建消息队列和路由逻辑。开发者必须为每条消息判断其接收者，代码会变得非常臃肿。
  - **框架优势 (`MsgHub`)**: `MsgHub` 提供了高级的通信抽象。我们只需定义不同的“频道”（如 `public_channel`, `werewolf_channel`），并将相应的智能体加入。发送消息时，只需调用 `channel.broadcast()`, 框架会自动处理底层的消息分发，代码简洁且不易出错。

- **3. 高度的模块化与可扩展性**:
  - **独立API调用**: 每增加一个新角色，就意味着可能要重写大部分的游戏流程和状态管理代码。
  - **框架优势 (Agent-Based Design)**: 每个智能体都是一个独立的、可插拔的单元。其行为由自身的系统提示和代码逻辑定义。添加一个新角色（如“猎人”）只需创建一个新的 `HunterAgent` 类和对应的prompt文件，然后在 `GameMasterAgent` 的流程中插入一个新的调用即可，对现有代码的侵入性极小。

- **4. 清晰的角色行为定义**:
  - **独立API调用**: 需要在代码中用大量的 `if/else` 语句来为不同角色的API调用构建不同的prompt。
  - **框架优势 (System Prompt)**: `PlayerAgent` 的行为主要由其加载的系统提示文件（如 `werewolf.txt`）定义。这实现了“配置即行为”，使得调整AI角色的性格和策略变得非常简单，无需修改任何代码。

## 3. 核心技术栈

- **框架**: `agentscope`
  - **作用**: 作为项目的核心框架，`agentscope` 提供了一整套用于构建多智能体应用的工具，包括智能体基类 (`AgentBase`)、消息传递机制 (`Msg`, `MsgHub`) 和模型封装 (`OpenAIChatModel`)。它极大地简化了智能体之间的通信和管理。

- **异步编程**: `asyncio`
  - **作用**: Python 的 `asyncio` 库被广泛应用于整个项目中，用于处理各个智能体的并发执行和I/O操作（如等待模型响应）。这确保了游戏流程的非阻塞性和高效性，尤其是在需要同时与多名AI玩家交互时。

- **大型语言模型 (LLM)**:
  - **作用**: 项目通过 `agentscope` 的 `OpenAIChatModel` 封装，可以接入任何兼容OpenAI API标准的大型语言模型。这些模型是AI玩家智能体（`PlayerAgent`）的“大脑”，负责根据系统提示（角色设定）和游戏过程中的信息，生成符合角色逻辑的发言和决策。

## 4. 架构设计

项目采用了清晰的模块化设计，主要由以下几个部分构成：

### 4.1. 核心智能体 (Agents)

- **`GameMasterAgent` (裁判)**:
  - **职责**: 作为游戏的中枢控制器，负责：
    1.  **状态维护**: 维护全局游戏状态，包括玩家存活列表、角色身份、游戏天数和阶段（夜晚、白天、投票）。
    2.  **流程驱动**: 按照狼人杀的游戏规则，依次推进夜晚行动、白天发言和投票环节。
    3.  **信息分发**: 通过通信中心 (`MsgHub`) 向所有玩家广播公共信息，并向特定角色（如狼人团队）发送私密信息。
    4.  **胜负裁定**: 根据预设的胜利条件（狼人数量 vs. 好人数量）判断游戏是否结束并宣布胜利方。

- **`PlayerAgent` (AI 玩家)**:
  - **职责**: 代表由LLM驱动的AI玩家。每个 `PlayerAgent` 实例都：
    1.  **拥有独立角色**: 在初始化时，通过加载不同的系统提示文件（如 `werewolf.txt`, `seer.txt`）来扮演特定角色。
    2.  **自主决策**: 根据裁判提供的信息和历史对话，独立生成决策和发言。
    3.  **ReActAgent**: 该项目使用了 `ReActAgent`，这意味着AI玩家具备一定的思考-行动（Thought-Action）能力，尽管在当前版本中主要用于生成对话。

- **`UserAgent` (人类玩家)**:
  - **职责**: 为人类玩家提供一个通过命令行输入参与游戏的接口。它继承自 `agentscope` 的 `UserAgent`，使其能无缝地融入到多智能体通信网络中。

### 4.2. 通信机制 (`MsgHub`)

- **公共频道 (`public_channel`)**:
  - **实现**: 一个包含了所有玩家（包括人类和AI）的 `MsgHub` 实例。
  - **作用**: 用于裁判发布全场公告，如“天黑请闭眼”、“玩家X被淘汰”等，以及广播所有玩家的公开言论。

- **私密频道 (`werewolf_channel`)**:
  - **实现**: 一个只包含所有狼人角色的 `MsgHub` 实例。
  - **作用**: 在夜晚阶段，裁判通过此频道向狼人团队广播任务（“请商量要淘汰的玩家”），狼人之间也可以通过此频道进行秘密协商（尽管当前版本简化为由一名代表决策）。

### 4.3. 配置与初始化 (`configs.py`, `main.py`)

- **`configs.py`**: 集中管理所有可配置项，如API密钥、模型名称和游戏设置（玩家人数、角色分配），实现了代码与配置的分离。
- **`main.py`**: 作为项目的启动入口，负责：
  1.  读取配置，随机分配角色。
  2.  实例化所有 `PlayerAgent` 和 `UserAgent`。
  3.  创建 `GameMasterAgent` 并将所有玩家注入。
  4.  启动整个异步游戏循环。

## 5. 关键功能实现详解

### 5.1. 游戏流程控制

游戏的核心逻辑位于 `GameMasterAgent` 的 `run_game` 方法中，这是一个大的异步循环，每一轮循环代表一个游戏日，包含 `_night_phase`, `_day_phase`, 和 `_vote_phase` 三个阶段。通过精确控制异步函数的调用顺序 (`await`)，保证了游戏流程的严格时序性。

### 5.2. 私密对话 (以狼人夜晚商议为例)

私密对话是狼人杀游戏的核心机制之一，`agentscope` 框架通过 `MsgHub` 对其进行了优雅的实现。

- **实现步骤**:
  1.  **创建私密频道**: 在 `GameMasterAgent` 的 `_setup_msghub` 方法中，系统首先筛选出所有身份为“werewolf”的玩家。然后，使用这些玩家作为参与者列表，创建一个名为 `werewolf_channel` 的 `MsgHub` 实例。
      ```python
      # 伪代码
      werewolves = [p for p in all_players if p.role == "werewolf"]
      self.werewolf_channel = MsgHub(participants=werewolves)
      ```
  2.  **发送私密消息**: 在 `_werewolf_action` 方法中，当裁判需要向狼人发布任务时，它会调用 `self.werewolf_channel.broadcast()`。由于这个频道在创建时就只包含了狼人玩家，`agentscope` 框架确保了这条消息只会被狼人智能体接收和观察到，其他任何角色（包括预言家、女巫等）都无法获取此信息，从而保证了通信的机密性。

### 5.3. 复杂逻辑判断 (以夜晚结算为例)

游戏中的许多裁决需要整合来自多个角色的信息并按规则进行判断，`GameMasterAgent` 作为中心协调者完美地处理了这一点。

- **场景**: 在一个夜晚，狼人选择淘汰 `Player_1`，而女巫对 `Player_1` 使用了解药，同时对 `Player_2` 使用了毒药。
- **实现流程 (`_night_settlement` 方法)**:
  1.  **信息收集**: 在夜晚阶段，`GameMasterAgent` 会依次调用 `_werewolf_action` 和 `_witch_action`。这些方法执行后，会将行动结果（如 `killed_by_werewolf`, `saved`, `poisoned`）存储在 `self.game_state["night_info"]` 字典中。
  2.  **规则判断**: `_night_settlement` 方法被调用时，它会读取 `night_info` 中的所有信息。
  3.  **优先级处理**: 该方法内嵌了狼人杀的核心规则，例如“解药的优先级高于击杀”。它会检查 `saved` 标志位，如果为 `True`，即使 `killed_by_werewolf` 有值，该玩家也不会被加入死亡名单。
  4.  **最终裁决**: 方法会综合所有条件，生成一个最终的死亡名单 `deaths`。在这个例子中，`Player_1` 因为被救而存活，`Player_2` 因为中毒而被加入死亡名单。最后，裁判只会向所有人公布 `Player_2` 的死讯。

这个过程展示了中心化逻辑处理的优势：如果没有 `GameMasterAgent` 来统一收集信息并执行裁决，那么开发者将需要在各个独立模块之间传递大量状态，并处理复杂的异步回调，极易出错。

### 5.4. 投票系统

投票过程在 `_vote_phase` 中实现。为了避免并发I/O冲突（特别是对于人类玩家的输入），系统采用串行方式收集投票：先异步地收集所有AI的投票，然后再等待人类玩家的输入。计票逻辑使用了Python的 `collections.Counter`，可以高效地统计票数并处理平票情况。

### 5.5. 日志记录 (`logger.py`)

项目包含一个全局的 `game_logger` 实例，用于详细记录游戏的全过程，包括：
- 游戏开始时的角色分配。
- 每个阶段的裁判公告。
- AI玩家的内部思考过程（通过静默捕获 `stdout` 实现）。
- 玩家的发言、投票和最终的遗言。
这为游戏复盘和AI行为分析提供了宝贵的数据。

## 6. 实际应用场景

- **多智能体协作研究平台**: 本项目是验证多智能体在混合动机（合作与对抗并存）场景下表现的理想平台。研究人员可以利用此框架测试不同LLM的推理、欺骗和协作能力。
- **LLM能力评估基准**: 通过量化AI在狼人杀游戏中的胜率和行为模式，可以为评估大型语言模型的逻辑推理和社交智能提供一个新的维度。
- **娱乐与交互体验**: 作为一个功能完整的游戏，本项目可以直接用于人机对战娱乐，为用户提供一个与多个高智能AI进行博弈的独特体验。

